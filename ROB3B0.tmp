#pragma config(Hubs,  S1, HTMotor,  HTMotor,  HTServo,  none)
#pragma config(Sensor, S2,     ,               sensorSONAR)
#pragma config(Sensor, S3,     HTGyro,         sensorI2CHiTechnicGyro)
#pragma config(Sensor, S4,     HTIRS2,         sensorHiTechnicIRSeeker1200)
#pragma config(Motor,  motorA,          motorTray,     tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     motorE,        tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     motorCollector, tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     motorD,        tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     motorScissor,  tmotorTetrix, openLoop)
#pragma config(Servo,  srvo_S1_C3_1,    servo1,               tServoStandard)
#pragma config(Servo,  srvo_S1_C3_2,    servo3,               tServoStandard)
#pragma config(Servo,  srvo_S1_C3_3,    servo2,               tServoStandard)
#pragma config(Servo,  srvo_S1_C3_4,    servo4,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_5,    servo5,               tServoNone)
#pragma config(Servo,  srvo_S1_C3_6,    servo6,               tServoNone)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "hitechnic-gyro.h"
#include "hitechnic-sensormux.h"
#include "hitechnic-irseeker-v2.h"

#include "JoystickDriver.c"

//Pre-definitions
bool ultrasonicBlock;
bool runningNav;
void turnByDegrees(int degrees);
void turnByDegreesClockwise(int degrees);
void turnByDegreesCounterClockwise(int degrees);
void travelMeters(double meters);
void travelMetersFast(double meters);
void travelMetersBackwards(double meters);
void travelMetersFastBackwards(double meters);
void compareInfrared(int *data);
void raiseScissorLift();
void lowerScissorLift();
void raiseGrabber();
void lowerGrabber();
void releaseBallCollector();
void runPath(string path);
void print(int s);
void printstring(string s);
void printdouble(double s);
int getInfrared();

void resetEncoders(){
	nMotorEncoder[motorD] = 0;
	nMotorEncoder[motorE] = 0;
}
//a
void runPath(char *path) {
	int state = 0;
	string tempfunc = "";

	/*
	for(int i = 0; i<sizeof(path); i++) {
		print(i);
		char chare = StringGetChar(path, i);
		string char2 = chare;
		if(state == 0) {
			printstring(char2);
			tempfunc = char2;
			state++;
		} else if (state == 4) {
			if(tempfunc == "a") {
				travelMeters(atoi(read)/100);
			} else if(tempfunc == "b") {
				travelMetersBackwards(atoi(read)/100);
			} else if(tempfunc == "c") {
				turnByDegreesClockwise(atoi(read));
			} else if(tempfunc == "d") {
				turnByDegreesCounterClockwise(atoi(read));
			} else {
			//printstring(tempfunc);
			}
			state = 0;
			read = "";
			tempfunc = "";
		} else {
			strcat(read, char2);
			state++;
		}
	}
	*/
	for(int i = 0; i<strlen(path); i+=4) {
		string read = "";
		char chare = path[i];
		tempfunc = chare;
		print(i);
		char b1 = path[i+1];
		char b2 = path[i+2];
		char b3 = path[i+3];
		string a1 = b1;
		string a2 = b2;
		string a3 = b3;
		strcat(read, a1);
		strcat(read, a2);
		strcat(read, a3);
		if(tempfunc == "a") {
				travelMeters((float) atoi(read)/100);
		} else if(tempfunc == "b") {
				travelMetersBackwards((float) atoi(read)/100);
		} else if(tempfunc == "c") {
				turnByDegreesClockwise(atoi(read));
		} else if(tempfunc == "d") {
			turnByDegreesCounterClockwise(atoi(read));
		} else if(tempfunc == "e") {
		  if(a3 == "1") {
		  	raiseScissorLift();
		  } else if(a3 == "2") {
		  	lowerScissorLift();
			} else if(a3 == "3") {
				raiseGrabber();
			} else if(a3 == "4") {
			  lowerGrabber();
			} else if(a3 == "5") {
				releaseBallCollector();
			}
		}
	}

}
void raiseScissorLift(){
	motor[motorScissor] = 100;
	wait1Msec(2000);
	motor[motorScissor] = 0;
}

void lowerScissorLift(){
	motor[motorScissor] = -100;
	wait1Msec(2000);
	motor[motorScissor] = 0;
}

void raiseGrabber(){
	servo[servo1] = 360;
	servo[servo2] = 20;
}

void lowerGrabber(){
	servo[servo1] = 80;
	servo[servo2] = 270;
}

void releaseBallCollector(){
	motor[motorCollector] = -20;
	wait1Msec(3000);
	motor[motorCollector] = 0;
}

void travelMetersFast(double meters){
	motor[motorD]=46;
	motor[motorE]=40;
	resetEncoders();
	while(nMotorEncoder[motorD] < 5633*meters){

	}
	motor[motorD]=0;
	motor[motorE]=0;
	resetEncoders();
	wait1Msec(50);
}
void travelMeters(double meters){
	//Motor D and Motor F are left side, Motor E, G are right side
	motor[motorD]=20;
	motor[motorE]=20;
	resetEncoders();
	//Magic number 5633 degrees of rotation per meters
	while(nMotorEncoder[motorE] < 5633*meters){
		//print(nMotorEncoder[motorE]);
		/*if(nMotorEncoder[motorD] < nMotorEncoder[motorE] + 360){
			motor[motorD] += 1;
			motor[motorE] -= 1;
		} else if(nMotorEncoder[motorD] + 360  > nMotorEncoder[motorE]){
			motor[motorD] -= 1;
			motor[motorE] += 1;
		}	*/
	}
	motor[motorD]=0;
	motor[motorE]=0;
	resetEncoders();
	wait1Msec(50);
}
void travelMetersBackwards(double meters){
	motor[motorD]= -20;
	motor[motorE]= -20;
	resetEncoders();
	//Magic number 5633 degrees of rotation per meters    //d = -10, e = -20
	while(nMotorEncoder[motorE] > -5633*meters){
	}
	motor[motorD]=0;
	motor[motorE]=0;
	resetEncoders();
	wait1Msec(50);
}

void

void travelMetersBackwardsFast(double meters){
	motor[motorD]=-46;
	motor[motorF]=-46;
	motor[motorE]=-40;
	motor[motorG]=-40;
	resetEncoders();
	//Magic number 5633 degrees of rotation per meters    //d = -10, e = -20
	while(nMotorEncoder[motorD] < -5633*meters){

	}
	motor[motorD]=0;
	motor[motorE]=0;
	resetEncoders();
	wait1Msec(50);
}

void turnByDegrees(int degrees) {
	int mul = 1;
	//Confirm direction (clockwise or counter-clockwise)
	if(degrees < 0) {
		mul = -1;
	}
	//Reset variables
	float prev_rot = 0;
	float total_distance = 0;
	resetEncoders();

	//compensate for Gyroscopic error
	float degreesToTurn = degrees - (degrees/13);
	motor[motorD] = 15 * mul;
	motor[motorE] = -15 * mul;
	clearTimer(T1);

	//Continue adding Gyroscopic output until turn is complete
	while(abs(total_distance) < abs(degreesToTurn)){
		float current_rot = HTGYROreadRot(HTGyro) + 14;
		float time = time1[T1];

		float distance = ((prev_rot+current_rot)/2)*time/1000;
		total_distance += distance;
		prev_rot = current_rot;
		clearTimer(T1);
		wait1Msec(10);
	}
motor[motorD] = 0;
motor[motorE] = 0;
}

void turnByDegreesCounterClockwise(int degrees) {
		turnByDegrees(-degrees);
}
void turnByDegreesClockwise(int degrees) {
		turnByDegrees(degrees);
}

void ram() {
	travelMetersFast(.1);
}
void getToTower2(){
	travelMeters(1.75);
	turnByDegreesCounterClockwise(90);
	travelMeters(0.55);
	turnByDegreesCounterClockwise(90);
}

void getToTower1(){
	travelMeters(1.75);
	turnByDegreesCounterClockwise(90);
	travelMeters(0.5);
	turnByDegreesCounterClockwise(55);
	travelMeters(0.64);
	turnByDegreesClockwise(55);
	travelMeters(1);
}

void getToTower3(){
	travelMeters(1.5);
	turnByDegreesCounterClockwise(90);
	travelMeters(1.1);
	turnByDegreesCounterClockwise(180);
}

task navigateToTower()
{
	runningNav = true;
	int data[4];
	data[0] = SensorValue[S4];
	//Drive down the ramp
	travelMeters(0.5);
	data[1] = SensorValue[S4];
	travelMeters(0.53);
	data[2] = SensorValue[S4];
	turnByDegreesClockwise(90);
	data[3] = SensorValue[S4];
	char path[] = "";
	runPath(path);

	runningNav = false;
}

task navigateCylinder(){
	runningNav = true;
	char pa[] = "a187d038a045a005c014c002a016c006c001a004a005d009c006c005c007c013c007c001a006c006c013a003c006c012c007a007c006c009c001a007c010c006a015c011a232b142";
	runPath(pa);
	runningNav = false;
}

task checkUltrasonic()
{
	while(true)
	{
		if(SensorValue[S2] < 15 || SensorValue[S2] == 255) ultrasonicBlock = true;
		else ultrasonicBlock = false;
	}
}

void init()
{
	startTask(checkUltrasonic);
	resetEncoders();
	tHTIRS2DSPMode _mode = DSP_1200;
}

int getInfrared(){
	int s1 = HTIRS2_AC_SSTR1;
	int s2 = HTIRS2_AC_SSTR2;
	int s3 = HTIRS2_AC_SSTR3;
	int s4 = HTIRS2_AC_SSTR4;
	int s5 = HTIRS2_AC_SSTR5;
	int sensors [5] = {s1, s2, s3, s4, s5};

	int biggest = 1;
	for(int i = 0; i < 5; i++){
		if(sensors[i]>biggest){
			biggest= i + 1;
		}
	}

	int mul;
	if(biggest == 2 || biggest == 3 || biggest == 4) {
		if(sensors[biggest - 1] > sensors[biggest + 1]) {
			mul = -1;
		}
	} else{
		mul = 1;
	}

	return 180 - (36 *(biggest-1) + 18*mul);
}

void compareInfrared(int *data){
	int totaldif1, totaldif2, totaldif3;
	int likelytower = 1;

	//Pre-recorded statement
	int tower1[] = {0,0,0,0};
	int tower2[] = {0,0,0,0};
	int tower3[] = {0,0,0,0};

	for(int i = 0; i++; i < 4){
		totaldif1 += abs(tower1[i] - data[i]);
	}
	for(int i = 0; i++; i < 4){
		totaldif2 += abs(tower2[i] - data[i]);
	}
	for(int i = 0; i++; i < 4){
		totaldif3 += abs(tower3[i] - data[i]);
	}
	if(totaldif1 < totaldif2 && totaldif1 < totaldif3) {
		//1 is most likely
		getToTower1();
	} else if (totaldif2 < totaldif3) {
	  //2 is most likely
		getToTower2();
	} else {
	  //3 is most likely
		getToTower3();
  }
}

void print(int s){
	NXTDisplayBigTextLine(3, "%d", s);
}
void printdouble(double s){
	NXTDisplayBigTextLine(3, "%d", s);
}
void printstring(string s){
	NXTDisplayBigTextLine(3, s);
}


task main()
{
	init();
	waitForStart();

	startTask(navigateCylinder);

	while(true){
		if(!runningNav && !ultrasonicBlock){
			resumeTask(navigateCylinder);
			runningNav = true;
		} else if(runningNav && ultrasonicBlock){
			suspendTask(navigateCylinder);
			runningNav = false;
		}
	}
}
