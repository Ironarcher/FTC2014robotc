#pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorSONAR)
#pragma config(Sensor, S3,     HTGyro,         sensorAnalogInactive)
#pragma config(Sensor, S4,     HTIRS2,         sensorI2CCustom)
#pragma config(Motor,  motorA,          motorTray,     tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     motorD,        tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C1_2,     motorE,        tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     motorF,        tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     motorG,        tmotorTetrix, openLoop, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "hitechnic-gyro.h"
#include "hitechnic-sensormux.h"
#include "hitechnic-irseeker-v2.h"

//Pre-definitions
bool ultrasonicBlock;
bool runningNav;
void goForward(int duration);
void goForwardFast(int duration);
void goBackward(int duration);
void turnClockwise(int duration);
void turnCounterClockwise(int duration);
void turnByDegreesClockwise(int degrees);
void turnByDegreesCounterClockwise(int degrees);
void travelMeters(double meters);
void travelMetersFast(double meters);
int getInfrared();

void resetEncoders(){
	nMotorEncoder[motorD] = 0;
	nMotorEncoder[motorE] = 0;
}

void goForward(int duration){
	//Motor D and Motor F are left side, Motor E, G are right side
	motor[motorD]=20;
	motor[motorF]=20;
	motor[motorE]=20;
	motor[motorG]=20;
	resetEncoders();
	for(int i = 0; i < 400; i++){
		if(nMotorEncoder[motorD] < nMotorEncoder[motorE]){
			motor[motorD] += 1;
			motor[motorE] -= 1;
		} else if(nMotorEncoder[motorD] > nMotorEncoder[motorE]){
			motor[motorD] -= 1;
			motor[motorE] += 1;
		}
		resetEncoders();
		string a;
		//a = nMotorEncoder[motorD] + "    " + nMotorEncoder[motorE];
		//nxtDisplayBigStringAt(1, 31, "%d", a);
		wait1Msec(duration/400);
	}
	motor[motorD]=0;
	motor[motorF]=0;
	motor[motorE]=0;
	motor[motorG]=0;
	wait1Msec(50);
}

void goForwardFast(int duration){
	motor[motorD]=46;
	motor[motorF]=45;
	motor[motorE]=40;
	motor[motorG]=40;
	resetEncoders();
	for(int i = 0; i < 20; i++){
		if(nMotorEncoder[motorD] < nMotorEncoder[motorE]){
			motor[motorD] += 2;
			motor[motorE] -= 2;
		} else if(nMotorEncoder[motorD] > nMotorEncoder[motorE]){
			motor[motorD] -= 2;
			motor[motorE] += 2;
		}
		resetEncoders();
		wait1Msec(duration/20);
	}
	motor[motorD]=0;
	motor[motorF]=0;
	motor[motorE]=0;
	motor[motorG]=0;
	wait1Msec(50);
}

void goBackward(int duration){
	motor[motorD]=-23;
	motor[motorF]=-23;
	motor[motorE]=-20;
	motor[motorG]=-20
	resetEncoders();
	for(int i = 0; i < 20; i++){
		if(nMotorEncoder[motorD] > nMotorEncoder[motorE]){
			motor[motorD] += 1;
			motor[motorE] -= 1;
		} else if(nMotorEncoder[motorD] < nMotorEncoder[motorE]){
			motor[motorD] -= 1;
			motor[motorE] += 1;
		}
		resetEncoders();
		wait1Msec(duration/20);
	}
	motor[motorD]=0;
	motor[motorF]=0;
	motor[motorE]=0;
	motor[motorG]=0;
	wait1Msec(50);
}

void turnClockwise(int duration){
	//Multiply degrees by 11 to get the duration
	int prev_rot;
	int total_distance;

	//loop
	int current_rot = HTGYROreadRot(HTGyro);
	int time = time1[T1];

	//calculate
	double distance = ((prev_rot+current_rot)/2)*time;
	total_distance += distance;
	prev_rot = current_rot;
	time1[T1] = 0;
	//end loop

	motor[motorD]=15;
	motor[motorE]=-15;

	motor[motorD]=0;
	motor[motorE]=0;
	wait1Msec(50);
}

void turnCounterClockwise(int duration){
	//Multiply degrees by 11 to get the duration
	motor[motorD]=-15;
	motor[motorE]=15;
	wait1Msec(duration);
	motor[motorD]=0;
	motor[motorE]=0;
	wait1Msec(50);
}
void turnByDegreesClockwise(int degrees) {
	int prev_rot;
	int total_distance;
	motor[motorD] = 15;
	motor[motorE] = -15;
	clearTimer(T1);

	while(total_distance < degrees){
		int current_rot = HTGYROreadRot(HTGyro);
		int time = time1[T1];

		double distance = ((prev_rot+current_rot)/2)*time;
		total_distance += distance;
		prev_rot = current_rot;
		clearTimer(T1);
		wait1Msec(100);
	}
motor[motorD] = 0;
motor[motorE] = 0;
}
void turnByDegreesCounterClockwise(int degrees) {
		int prev_rot;
	int total_distance;
	motor[motorD] = -15;
	motor[motorE] = 15;
	clearTimer(T2);

	while(total_distance < degrees){
		int current_rot = HTGYROreadRot(HTGyro);
		int time = time1[T2];

		double distance = ((prev_rot+current_rot)/2)*time;
		total_distance += distance;
		prev_rot = current_rot;
		clearTimer(T2);
		wait1Msec(100);
	}
motor[motorD] = 0;
motor[motorE] = 0;
}

void travelMetersFast(double meters){
	int conversion = (int)(1177 * meters);
	goForwardFast(conversion);
}

void travelMeters(double meters){
	int conversion = (int)(2353 * meters);
	goForward(conversion);
}


int getTowerPosition(){
	int position;
	if(getInfrared() == 5){
		//if infrared sensor is straight ahead, position is tower position 1
		position = 1;
		} else if (getInfrared() == 6){
		position = 2;
		} else if (getInfrared() == 7){
		position = 3;
	}

	return position;
}


void getToTower2(){
	turnByDegreesCounterClockwise(10);
	travelMetersFast(1);
}

void getToTower1(){
	turnByDegreesCounterClockwise(45);
	travelMeters(.6);
	turnByDegreesClockwise(70);
	travelMetersFast(.8);
}

void getToTower3(){
	travelMeters(1.5); //get off the ramp
	turnByDegreesCounterClockwise(90);
	travelMeters(0.5);
	turnByDegreesCounterClockwise(45);
	travelMeters(0.4);
	turnByDegreesClockwise(15);
	travelMetersFast(1);
}

task navigateToTower()
{
	runningNav = true;
	travelMeters(1.03);
	turnByDegreesCounterClockwise(86);
	travelMeters(0.55);
	bNxtLCDStatusDisplay = true;
	eraseDisplay();
	nxtDisplayBigTextLine(3, "%d, %d", getTowerPosition(), getTowerPosition());
	if(getTowerPosition() == 1) getToTower1();
	else if(getTowerPosition() == 2) getToTower2();
	else if(getTowerPosition() == 3) getToTower3();
	//getToTower3();
	runningNav = false;
}

task checkUltrasonic()
{
	while(true)
	{
		if(SensorValue[S2] > 600) ultrasonicBlock = true;
		else ultrasonicBlock = false;
	}
}

void init()
{
	startTask(checkUltrasonic);
	tHTIRS2DSPMode _mode = DSP_1200;
}

int getInfrared(){
	int s1 = HTIRS2_AC_SSTR1;
	int s2 = HTIRS2_AC_SSTR2;
	int s3 = HTIRS2_AC_SSTR3;
	int s4 = HTIRS2_AC_SSTR4;
	int s5 = HTIRS2_AC_SSTR5;
	int sensors [5] = {s1, s2, s3, s4, s5};

	int biggest = 1;
	for(int i = 0; i < 5; i++){
		if(sensors[i]>biggest){
			biggest=sensors[i] + 1;
		}
	}

	int mul;
	if(biggest == 2 || biggest == 3 || biggest == 4) {
		if(sensors[biggest - 1] > sensors[biggest + 1]) {
			mul = -1;
		}
	} else{
		mul = 1;
	}

	return (36 *(biggest-1) + 18*mul);
}

task main()
{
	init();
	//nxtDisplayBigStringAt(0, 31,"%d", getInfrared());
	travelMeters(15);
	wait1Msec(1000);
	nxtDisplayBigStringAt(0, 31,"%d", getInfrared());
	wait1Msec(5000);
	turnByDegreesCounterClockwise(90);
	wait1Msec(1000);
	nxtDisplayBigStringAt(0, 31,"%d", getInfrared());
	wait1Msec(10000);
	startTask(navigateToTower);
	while(true){
		if(!runningNav && !ultrasonicBlock){
			resumeTask(navigateToTower);
			runningNav = true;
		} else if(runningNav && ultrasonicBlock){
			suspendTask(navigateToTower);
			runningNav = false;
		}
	}
}
