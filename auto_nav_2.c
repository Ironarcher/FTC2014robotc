 #pragma config(Hubs,  S1, HTMotor,  HTMotor,  none,     none)
#pragma config(Sensor, S1,     ,               sensorI2CMuxController)
#pragma config(Sensor, S2,     ,               sensorSONAR)
#pragma config(Sensor, S3,     HTGyro,         sensorAnalogInactive)
#pragma config(Sensor, S4,     HTIRS2,         sensorI2CCustom)
#pragma config(Motor,  motorA,          motorTray,     tmotorNXT, PIDControl, encoder)
#pragma config(Motor,  mtr_S1_C1_1,     motorDrive,    tmotorTetrix, openLoop)
#pragma config(Motor,  mtr_S1_C1_2,     motorE,        tmotorTetrix, openLoop, encoder)
#pragma config(Motor,  mtr_S1_C2_1,     motorD,        tmotorTetrix, openLoop, reversed, encoder)
#pragma config(Motor,  mtr_S1_C2_2,     collector,     tmotorTetrix, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "hitechnic-gyro.h"
#include "hitechnic-sensormux.h"
#include "hitechnic-irseeker-v2.h"


//Pre-definitions
bool ultrasonicBlock;
bool runningNav;
void turnByDegrees(int degrees);
void turnByDegreesClockwise(int degrees);
void turnByDegreesCounterClockwise(int degrees);
void travelMeters(double meters);
void travelMetersFast(double meters);
void travelMetersBackwards(double meters);
void travelMetersFastBackwards(double meters);
void runPath(string path);
void print(int s);
int getInfrared();

void resetEncoders(){
	nMotorEncoder[motorD] = 0;
	nMotorEncoder[motorE] = 0;
}
//a
void runPath(string path) {
	int state = 0;
	string tempfunc = "";
	string read = "";
	for(int i = 0; i<sizeof(path); i++) {
		char chare = StringGetChar(path, i);
		print(3);
		if(state == 0) {
			tempfunc = chare;
			state++;
		} else if (state == 3) {
			if(tempfunc == "a") {
				travelMeters(atoi(read)/100);
			} else if(tempfunc == "b") {
				travelMetersBackwards(atoi(read)/100);
			} else if(tempfunc == "c") {
				turnByDegreesClockwise(atoi(read));
			} else if(tempfunc == "d") {
				turnByDegreesCounterClockwise(atoi(read));
			} else {
				return;
			}
			state = 0;
			read = "";
			tempfunc = "";
		} else {
			read = strcat(read, chare);
			state++;
		}
	}

}
void travelMeters(double meters){
	//Motor D and Motor F are left side, Motor E, G are right side
	motor[motorD]=20;
	motor[motorE]=20;
	resetEncoders();
	//Magic number 5633 degrees of rotation per meters
	while(nMotorEncoder[motorE] < 5633*meters){
		print(nMotorEncoder[motorE]);
		/*if(nMotorEncoder[motorD] < nMotorEncoder[motorE] + 360){
			motor[motorD] += 1;
			motor[motorE] -= 1;
		} else if(nMotorEncoder[motorD] + 360  > nMotorEncoder[motorE]){
			motor[motorD] -= 1;
			motor[motorE] += 1;
		}	*/
	}
	motor[motorD]=0;
	motor[motorE]=0;
	resetEncoders();
	wait1Msec(50);
}

void travelMetersFast(double meters){
	motor[motorD]=46;
	motor[motorE]=40;
	resetEncoders();
	while(nMotorEncoder[motorD] < 5633*meters){

	}
	motor[motorD]=0;
	motor[motorE]=0;
	resetEncoders();
	wait1Msec(50);
}

void travelMetersBackwards(double meters){
	motor[motorD]=-23;
	motor[motorF]=-23;
	motor[motorE]=-20;
	motor[motorG]=-20;
	resetEncoders();
	//Magic number 5633 degrees of rotation per meters    //d = -10, e = -20
	while(nMotorEncoder[motorD] < -5633*meters){

	}
	motor[motorD]=0;
	motor[motorE]=0;
	resetEncoders();
	wait1Msec(50);
}

void travelMetersBackwardsFast(double meters){
	motor[motorD]=-46;
	motor[motorF]=-46;
	motor[motorE]=-40;
	motor[motorG]=-40;
	resetEncoders();
	//Magic number 5633 degrees of rotation per meters    //d = -10, e = -20
	while(nMotorEncoder[motorD] < -5633*meters){

	}
	motor[motorD]=0;
	motor[motorE]=0;
	resetEncoders();
	wait1Msec(50);
}

void turnByDegrees(int degrees) {
	int mul = 1;
	if(degrees < 0) {
		mul = -1;
	}
	float prev_rot = 0;
	float total_distance = 0;
	resetEncoders();
	float degreesToTurn = degrees - (degrees/27);
	motor[motorD] = 15 * mul;
	motor[motorE] = -15 * mul;
	clearTimer(T1);

	while(abs(total_distance) < abs(degreesToTurn)){
		float current_rot = HTGYROreadRot(HTGyro) +14;
		print(total_distance);
		float time = time1[T1];

		float distance = ((prev_rot+current_rot)/2)*time/1000;
		total_distance += distance;
		prev_rot = current_rot;
		clearTimer(T1);
		wait1Msec(10);
	}
motor[motorD] = 0;
motor[motorE] = 0;
}

void turnByDegreesCounterClockwise(int degrees) {
		turnByDegrees(-degrees);
}
void turnByDegreesClockwise(int degrees) {
		turnByDegrees(degrees);
}


int getInfrared(){
	return SensorValue[S2];
}


int getTowerPosition(){
	int position;
	if(getInfrared() == 5){
		//if infrared sensor is straight ahead, position is tower position 1
		position = 1;
		} else if (getInfrared() == 6){
		position = 2;
		} else if (getInfrared() == 7){
		position = 3;
	}

	return position;
}

void ram() {
	travelMetersFast(.1);
}
void getToTower2(){
	travelMeters(1.75);
	turnByDegreesCounterClockwise(90);
	travelMeters(0.55);
	turnByDegreesCounterClockwise(90);
}

void getToTower1(){
	travelMeters(1.75);
	turnByDegreesCounterClockwise(90);
	travelMeters(0.5);
	turnByDegreesCounterClockwise(55);
	travelMeters(0.64);
	turnByDegreesClockwise(55);
	travelMeters(1);
}

void getToTower3(){
	travelMeters(1.5);
	turnByDegreesCounterClockwise(90);
	travelMeters(1.1);
	turnByDegreesCounterClockwise(180);
}

task navigateToTower()
{
	runningNav = true;
	travelMeters(1.03);
	turnByDegreesCounterClockwise(86);
	travelMeters(0.55);
	bNxtLCDStatusDisplay = true;
	eraseDisplay();
	nxtDisplayBigTextLine(3, "%d, %d", getTowerPosition(), getTowerPosition());
	if(getTowerPosition() == 1) getToTower1();
	else if(getTowerPosition() == 2) getToTower2();
	else if(getTowerPosition() == 3) getToTower3();
	//getToTower3();
	runningNav = false;
}

task checkUltrasonic()
{
	while(true)
	{
		if(SensorValue[S2] > 600) ultrasonicBlock = true;
		else ultrasonicBlock = false;
	}
}

void init()
{
	startTask(checkUltrasonic);
	resetEncoders();
	tHTIRS2DSPMode _mode = DSP_1200;
}

int getInfrared(){
	int s1 = HTIRS2_AC_SSTR1;
	int s2 = HTIRS2_AC_SSTR2;
	int s3 = HTIRS2_AC_SSTR3;
	int s4 = HTIRS2_AC_SSTR4;
	int s5 = HTIRS2_AC_SSTR5;
	int sensors [5] = {s1, s2, s3, s4, s5};

	int biggest = 1;
	for(int i = 0; i < 5; i++){
		if(sensors[i]>biggest){
			biggest=sensors[i] + 1;
		}
	}

	int mul;
	if(biggest == 2 || biggest == 3 || biggest == 4) {
		if(sensors[biggest - 1] > sensors[biggest + 1]) {
			mul = -1;
		}
	} else{
		mul = 1;
	}

	return 36 *(biggest-1) + 18*mul;
}

void print(int s){
	NXTDisplayBigTextLine(3, "%d", s);
}


task main()
{

	init();
	//getToTower3();
	string s = "a100";
	runPath(s);
	while(true){
		if(!runningNav && !ultrasonicBlock){
			resumeTask(navigateToTower);
			runningNav = true;
		} else if(runningNav && ultrasonicBlock){
			suspendTask(navigateToTower);
			runningNav = false;
		}
	}
}
